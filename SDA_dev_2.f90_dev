!!!
! Elspeth KH Lee - Aug 2023 : Initial version
! sw: Adding layer method with scattering
! lw: Absorption Approximation following Li (2002) - This is the exoponential in tau method
!     Pros: Very fast method with LW scattering approximation, no matrix inversions
!     Cons: Not technically multiple scattering (can be quite innacurate at even moderate albedo)
!!!

module ts_AA_E_mod
  use, intrinsic :: iso_fortran_env
  implicit none

  !! Precision variables
  integer, parameter :: dp = REAL64

  !! Required constants
  real(dp), parameter :: pi = 4.0_dp * atan(1.0_dp)
  real(dp), parameter :: twopi = 2.0_dp * pi
  real(dp), parameter :: sb = 5.670374419e-8_dp

  !! Legendre quadrature for 1 nodes
  ! integer, parameter :: nmu = 1
  ! real(dp), dimension(nmu), parameter :: uarr = (/1.0_dp/1.6487213_dp/)
  ! real(dp), dimension(nmu), parameter :: w = (/1.0_dp/)
  ! real(dp), dimension(nmu), parameter :: wuarr = uarr * w

  !! Legendre quadrature for 2 nodes
  integer, parameter :: nmu = 2
  real(dp), dimension(nmu), parameter :: uarr = (/0.21132487_dp, 0.78867513_dp/)
  real(dp), dimension(nmu), parameter :: w = (/0.5_dp, 0.5_dp/)
  real(dp), dimension(nmu), parameter :: wuarr = uarr * w

  public :: ts_AA_E
  private :: lw_AA_E, sw_SDA, sw_adding, linear_log_interp, bezier_interp

contains

  subroutine ts_AA_E(surf, Bezier, nlay, nlev, Ts, Tl, pl, pe, tau_Ve, tau_IRe, mu_z, F0, Tint, AB, &
    & sw_a, sw_g, lw_a, lw_g, sw_a_surf, lw_a_surf, net_F, olr, asr, net_Fs)
    implicit none

    !! Input variables
    logical, intent(in) :: surf, Bezier
    integer, intent(in) :: nlay, nlev
    real(dp), intent(in) :: F0, mu_z, Tint, AB, sw_a_surf, lw_a_surf, Ts
    real(dp), dimension(nlay), intent(in) :: Tl, pl
    real(dp), dimension(nlev), intent(in) :: pe
    real(dp), dimension(nlev), intent(in) :: tau_Ve, tau_IRe
    real(dp), dimension(nlay), intent(in) :: sw_a, sw_g, lw_a, lw_g

    !! Output variables
    real(dp), intent(out) :: olr, asr, net_Fs
    real(dp), dimension(nlev), intent(out) :: net_F

    !! Work variables
    integer :: i
    real(dp) :: Finc, be_int
    real(dp), dimension(nlev) :: Te, be
    real(dp), dimension(nlev) :: sw_down, sw_up, lw_down, lw_up
    real(dp), dimension(nlev) :: lw_net, sw_net

    !! Find temperature at layer edges through interpolation and extrapolation
    if (Bezier .eqv. .True.) then
      ! Perform interpolation using Bezier peicewise polynomial interpolation
      do i = 2, nlay-1
        call bezier_interp(pl(i-1:i+1), Tl(i-1:i+1), 3, pe(i), Te(i))
        !print*, i, pl(i), pl(i-1), pe(i), Tl(i-1), Tl(i), Te(i)
      end do
      call bezier_interp(pl(nlay-2:nlay), Tl(nlay-2:nlay), 3, pe(nlay), Te(nlay))
    else
      ! Perform interpolation using linear interpolation
      do i = 2, nlay
        call linear_log_interp(pe(i), pl(i-1), pl(i), Tl(i-1), Tl(i), Te(i))
        !print*, i, pl(i), pl(i-1), pe(i), Tl(i-1), Tl(i), Te(i)
      end do
    end if

    ! Edges are linearly interpolated
    Te(1) = 10.0_dp**(log10(Tl(1)) + (log10(pe(1)/pe(2))/log10(pl(1)/pe(2))) * log10(Tl(1)/Te(2)))
    Te(nlev) = 10.0_dp**(log10(Tl(nlay)) + (log10(pe(nlev)/pe(nlay))/log10(pl(nlay)/pe(nlay))) * log10(Tl(nlay)/Te(nlay)))

    !! Shortwave flux calculation
    if (mu_z > 0.0_dp) then
      Finc = (1.0_dp - AB) * F0
      call sw_SDA(nlay, nlev, Finc, tau_Ve(:), mu_z, sw_a, sw_g, sw_a_surf, sw_down(:), sw_up(:))
      !call sw_adding(nlay, nlev, Finc, tau_Ve(:), mu_z, sw_a, sw_g, sw_a_surf, sw_down(:), sw_up(:))
    else
      sw_down(:) = 0.0_dp
      sw_up(:) = 0.0_dp
    end if

    !! Longwave two-stream flux calculation
    be(:) = (sb * Te(:)**4)/pi  ! Integrated planck function intensity at levels
    if (surf .eqv. .True.) then
      be_int = (sb * Ts**4)/pi
    else
      be_int = (sb * Tint**4)/pi ! Integrated planck function intensity for internal temperature
    end if

    call lw_AA_E(surf, nlay, nlev, be, be_int, tau_IRe(:), lw_a, lw_g, lw_a_surf, lw_up(:), lw_down(:))

    !! Net fluxes at each level
    lw_net(:) = lw_up(:) - lw_down(:)
    sw_net(:) = sw_up(:) - sw_down(:)
    net_F(:) = lw_net(:) + sw_net(:)

    !! Net surface flux (for surface temperature evolution)
    !! We have to define positive as downward (heating) and cooling (upward) in this case
    net_Fs = sw_down(nlev) + lw_down(nlev) - lw_up(nlev)

    !! Output the olr
    olr = lw_up(1)

    !! Output asr
    asr = sw_down(1) - sw_up(1)

  end subroutine ts_AA_E

  subroutine lw_AA_E(surf, nlay, nlev, be, be_int, tau_IRe, ww, gg, lw_a_surf, lw_up, lw_down)
    implicit none

    !! Input variables
    logical, intent(in) :: surf
    integer, intent(in) :: nlay, nlev
    real(dp), dimension(nlev), intent(in) :: be, tau_IRe
    real(dp), dimension(nlay), intent(in) :: ww, gg
    real(dp), intent(in) :: be_int, lw_a_surf

    !! Output variables
    real(dp), dimension(nlev), intent(out) :: lw_up, lw_down

    !! Work variables and arrays
    integer :: k, m
    real(dp), dimension(nlay) :: w0, hg, fc
    real(dp), dimension(nlay) :: dtau, Bln, eps, dtau_a
    real(dp), dimension(nmu, nlay) :: T, nup, nun
    real(dp), dimension(nmu, nlev) :: lw_up_g, lw_down_g

    real(dp), dimension(nlay) :: sigma_sq, pmom2, c
    integer, parameter :: nstr = nmu*2

    !! Calculate dtau in each layer
    dtau(:) = tau_IRe(2:) - tau_IRe(1:nlay)

    !! Delta-M+ scaling (Following DISORT: Lin et al. 2018)
    !! Assume HG phase function for scaling
    fc(:) = gg(:)**(nstr)
    pmom2(:) = gg(:)**(nstr+1)

    where (fc(:) /=  pmom2(:))
      sigma_sq(:) = real((nstr+1)**2 - nstr**2,dp) / &
      & ( log(fc(:)**2/pmom2(:)**2) )
      c(:) = exp(real(nstr**2,dp)/(2.0_dp*sigma_sq(:)))
      fc(:) = c(:)*fc(:)

      w0(:) = ww(:)*((1.0_dp - fc(:))/(1.0_dp - fc(:)*ww(:)))
      dtau(:) = (1.0_dp - ww(:)*fc(:))*dtau(:)

    elsewhere
      w0(:) = ww(:)
    end where

    hg(:) = gg(:)

    !! Log B with tau function
    do k = 1, nlay
      if (dtau(k) < 1.0e-9_dp) then
        ! Too low optical depth for numerical stability, Bln = 0
        Bln(k) = 0.0_dp
      else
        ! Log B with tau value
        Bln(k) = log(be(k+1)/be(k))/dtau(k)
      end if
    end do

    !! modified co-albedo epsilon
    eps(:) = sqrt((1.0_dp - w0(:))*(1.0_dp - hg(:)*w0(:)))
    !eps(:) = (1.0_dp - w0(:))

    !! Absorption/modified optical depth for transmission function
    dtau_a(:) = eps(:)*dtau(:)

    ! Zero the total flux arrays
    lw_up(:) = 0.0_dp
    lw_down(:) = 0.0_dp

    !! Start loops to integrate in mu space
    do m = 1, nmu

      !! Begin two-stream loops
      !! Perform downward loop first - also calculate efficency variables
      ! Top boundary condition - 0 flux downward from top boundary
      lw_down_g(m,1) = 0.0_dp
      do k = 1, nlay

        !! Efficency variables
        T(m,k) = exp(-dtau_a(k)/uarr(m))
        nup(m,k) = 1.0_dp/(1.0_dp + uarr(m)*Bln(k)/eps(k))
        nun(m,k) = 1.0_dp/(1.0_dp - uarr(m)*Bln(k)/eps(k))

        lw_down_g(m,k+1) = lw_down_g(m,k)*T(m,k) + &
          & nup(m,k) * (be(k+1) - be(k)*T(m,k))
          !print*, k, m, lw_down_g(k+1), alkap(k), (be(k) - alkap(k)*uarr(m))*exp(-dtau_a(k)/uarr(m))
      end do


      !! Perform upward loop
      if (surf .eqv. .True.) then
        ! Surface boundary condition given by surface temperature + reflected longwave radiaiton
        lw_up_g(m,nlev) = lw_down_g(m,nlev)*lw_a_surf + be_int
      else
        ! Lower boundary condition - internal heat definition Fint = F_down - F_up
        ! here the lw_a_surf is assumed to be = 1 as per the definition
        ! here we use the same condition but use intensity units to be consistent
        lw_up_g(m,nlev) = lw_down_g(m,nlev) + be_int
      end if

      do k = nlay, 1, -1
        lw_up_g(m,k) = lw_up_g(m,k+1)*T(m,k) + &
          & nun(m,k) * (be(k) - be(k+1)*T(m,k))
      end do

      !! Sum up flux arrays with Gaussian quadrature weights and points for this mu stream
      lw_down(:) = lw_down(:) + lw_down_g(m,:) * wuarr(m)
      lw_up(:) = lw_up(:) + lw_up_g(m,:) * wuarr(m)

    end do

    !! The flux is the integrated intensity * 2pi
    lw_down(:) = twopi * lw_down(:)
    lw_up(:) = twopi * lw_up(:)

  end subroutine lw_AA_E

  subroutine sw_SDA(nlay, nlev, Finc, tau_Ve, mu_z, ww, gg, w_surf, sw_down, sw_up)
    implicit none

    !! Input variables
    integer, intent(in) :: nlay, nlev
    real(dp), intent(in) :: Finc, mu_z, w_surf
    real(dp), dimension(nlev), intent(in) :: tau_Ve
    real(dp), dimension(nlay), intent(in) :: ww, gg

    !! Output variables
    real(dp), dimension(nlev), intent(out) :: sw_down, sw_up

    !! Work variables
    integer :: k
    real(dp), dimension(nlay) :: w0, dtau, hg
    real(dp), dimension(nlev) :: tau, T
    real(dp) :: mu1, mu2, mu3, f0
    real(dp) :: om0, om1, om2, om3
    real(dp) :: a0, a1, a2, a3, b0, b1, b2, b3
    real(dp) :: e1, e2
    real(dp) :: beta, gam, k1, k2, R1, R2, P1, P2, Q1, Q2
    real(dp) :: eta0, eta1, eta2, eta3, del0, del1, del2, del3, delta
    real(dp) :: h1, h2, h3, h4
    real(dp) :: w11,w12,w13,w14,w21,w22,w23,w24,wa,wb,wc,wd,we,wf,det
    real(dp) :: ya,yb,yc,yd,ye,yf,yg,yh,c1,d1,c2,d2,c1t,c2t,d1t,d2t,ted0,ted1,ted2,ted3, &
           & teu0,teu1,teu2,teu3

    real(dp), dimension(nlay,2) :: Rdir, Tdir
    real(dp), dimension(nlay,2,2) :: Rdiff, Tdiff 

    real(dp), dimension(nlev,2) :: T1k, R1k
    real(dp), dimension(nlev,2,2) :: Rst1k, Rd1k

    real(dp), dimension(nlev,2) :: U, D

    real(dp), dimension(nlay) :: fc, sigma_sq, pmom2, c, dtr
    integer, parameter :: nstr = 4
    real(dp), parameter :: eps_10 = 1.0e-10_dp

    integer :: l, km1, lp1
    real(dp)  :: c11, c12, c21, c22, pmod, t11, t12, t21, t22, b11, b12, &
           &   b21, b22, uu1, uu2, du1, du2, a11, a12, a21, a22, r11, r12, r21, r22

    real(dp), dimension(nlev) :: scumdtr, reflt, trant

    !! If zero albedo across all atmospheric layers then return direct beam only
    if (all(ww(:) <= 1.0e-6_dp)) then
      sw_down(:) = Finc * mu_z * exp(-tau_Ve(:)/mu_z)
      sw_down(nlev) = sw_down(nlev) * (1.0_dp - w_surf) ! The surface flux for surface heating is the amount of flux absorbed by surface
      sw_up(:) = 0.0_dp ! We assume no upward flux here even if surface albedo
      return
    end if

    !! Calculate dtau in each layer
    dtau(:) = tau_Ve(2:) - tau_Ve(1:nlay)

    !! Delta-M+ scaling (Following DISORT: Lin et al. 2018)
    !! Assume HG phase function for scaling
    fc(:) = gg(:)**(nstr)
    pmom2(:) = gg(:)**(nstr+1)

    where (fc(:) /=  pmom2(:))
      sigma_sq(:) = real((nstr+1)**2 - nstr**2,dp) / &
      & ( log(fc(:)**2/pmom2(:)**2) )
      c(:) = exp(real(nstr**2,dp)/(2.0_dp*sigma_sq(:)))
      fc(:) = c(:)*fc(:)

      w0(:) = ww(:)*((1.0_dp - fc(:))/(1.0_dp - fc(:)*ww(:)))
      dtau(:) = (1.0_dp - ww(:)*fc(:))*dtau(:)

    elsewhere
      w0(:) = ww(:)
      fc(:) = 0.0_dp
    end where

    hg(:) = gg(:)

    !! Reform edge optical depths
    tau(1) = tau_Ve(1)
    do k = 1, nlay
      tau(k+1) = tau(k) + dtau(k)
    end do

    !! Direct transmission to level
    !T(1:nlay) = exp(-dtau(:)/mu_z)

    !! Start SDA calculation

    !! First find the Reflection and Transmission coefficents (direct and diffuse) for each layer
    do k = 1, nlay

      dtr(k) = exp(-dtau(k)/mu_z)

      !! Mu moments
      mu1 = mu_z
      mu2 = mu_z**2
      mu3 = mu_z**3

      !! Inverse zenith angle
      f0 = 1.0_dp/mu_z

      !! Omega Legendre polynomial - scale with delta-M+
      om0 = 1.0_dp
      om1 = 3.0_dp * (hg(k) - fc(k))/(1.0_dp - fc(k))
      om2 = 5.0_dp * (hg(k)**2 - fc(k))/(1.0_dp - fc(k))
      om3 = 7.0_dp * (hg(k)**3 - fc(k))/(1.0_dp - fc(k))

      ! om0 = w0(k)
      ! om1 = 3.0_dp * w0(k)*hg(k)
      ! om2 = 5.0_dp * w0(k)*hg(k)**2
      ! om3 = 7.0_dp * w0(k)*hg(k)**3

      !! Find the a coefficents
      a0 =  1.0_dp - w0(k)*om0 + eps_10
      a1 =  3.0_dp - w0(k)*om1 + eps_10
      a2 =  5.0_dp - w0(k)*om2 + eps_10
      a3 =  7.0_dp - w0(k)*om3 + eps_10

      !! Find the b coefficents
      b0 = 0.25_dp * w0(k)*om0
      b1 = 0.25_dp * w0(k)*om1 * -(mu1)
      b2 = 0.125_dp * w0(k)*om2 * (3.0_dp * mu2 - 1.0_dp)
      b3 = 0.125_dp * w0(k)*om3 * (5.0_dp * -mu3 - 3.0_dp*-(mu_z))

      !! Find beta and gamma
      beta = a0*a1 + (4.0_dp/9.0_dp)*a0*a3 + (1.0_dp/9.0_dp)*a2*a3
      gam = (4.0_dp/9.0_dp)*a0*a1*a2*a3

      !! Find k values
      k1 = (beta + sqrt((beta**2 - gam)))/2.0_dp
      k2 = (beta - sqrt((beta**2 - gam)))/2.0_dp

      k1 = sqrt(k1)
      k2 = sqrt(k2)

      !! Find e values
      e1 = exp(-k1*dtau(k))
      e2 = exp(-k2*dtau(k))     
      

      !! Find the delta values
      delta = 9.0_dp*(f0**4 - beta*f0**2 + gam)
      del0 = (a1*b0 - b1*f0)*(a2*a3 - 9.0_dp*f0**2) + 2.0_dp*f0**2*(a3*b2 - 2.0_dp*a3*b0 - 3.0_dp*b3*f0)
      del1 = (a0*b1 - b0*f0)*(a2*a3 - 9.0_dp*f0**2) - 2.0_dp*a0*f0*(a3*b2 - 3.0_dp*b3*f0)
      del2 = (a3*b2 - 3.0_dp*b3*f0)*(a0*a1 - f0**2) - 2.0_dp*a3*f0*(a0*b1 - b0*f0)
      del3 = (a2*b3 - 3.0_dp*b2*f0)*(a0*a1 - f0**2) + f0**2*(6.0_dp*a0*b1 - 4.0_dp*a0*b3 - 6.0_dp*b0*f0)

      !! Find the eta values
      eta0 = del0/delta
      eta1 = del1/delta
      eta2 = 0.625_dp * del2/delta
      eta3 = del3/delta

    !! Find R, P and Q coefficents
      R1 = -3.0_dp/2.0_dp * (a0*a1/k1 - k1)/a3
      R2 = -3.0_dp/2.0_dp * (a0*a1/k2 - k2)/a3
      P1 = -a0/k1
      P2 = -a0/k2
      Q1 = 0.3125_dp * (a0*a1/k1**2 - 1.0_dp)
      Q2 = 0.3125_dp * (a0*a1/k2**2 - 1.0_dp)

      h1 = -(0.5d0 * eta0 - eta1 + eta2)
      h2 = -(-0.125d0 * eta0 + eta2 - eta3)
      h3 = -(0.5d0 * eta0 + eta1 + eta2) * dtr(k)
      h4 = -(-0.125d0 * eta0 + eta2 + eta3) * dtr(k)

      w11 =  0.5d0 - p1 + q1
      w12 = (0.5d0 + p1 + q1) * e1
      w13 =  0.5d0 - p2 + q2
      w14 = (0.5d0 + p2 + q2) * e2
      w21 =  -0.125d0 + q1 - r1
      w22 = (-0.125d0 + q1 + r1) * e1
      w23 =  -0.125d0 + q2 - r2
      w24 = (-0.125d0 + q2 + r2) * e2

      wa =  w11 * w22 - w21 * w12
      wb =  w14 * w23 - w24 * w13
      wc =  w11 * w23 - w21 * w13
      wd =  w11 * w24 - w21 * w14
      we =  w12 * w23 - w22 * w13
      wf =  w12 * w24 - w22 * w14    
      
     det             =  1.0d0 / (2.0d0 * wa * wb - wc * wc + wd * wd + we * we - wf * wf)
      ya              = ( w22 * wb - w23 * wc + w24 * wd) * det
      yb              = (-w12 * wb + w13 * wc - w14 * wd) * det
      yc              = ( w23 * we - w24 * wf - w21 * wb) * det
      yd              = (-w13 * we + w14 * wf + w11 * wb) * det
      ye              = ( w21 * wc - w22 * we - w24 * wa) * det
      yf              = (-w11 * wc + w12 * we + w14 * wa) * det
      yg              = ( w23 * wa - w21 * wd + w22 * wf) * det
      yh              = (-w13 * wa + w11 * wd - w12 * wf) * det
!
      c1              =  ya * h1 + yb * h2 + yc * h3 + yd * h4
      d1              =  yc * h1 + yd * h2 + ya * h3 + yb * h4
      c2              =  ye * h1 + yf * h2 + yg * h3 + yh * h4
      d2              =  yg * h1 + yh * h2 + ye * h3 + yf * h4
!
      c1t             =  c1 * e1
      c2t             =  c2 * e2
      d1t             =  d1 * e1
      d2t             =  d2 * e2
!
      teu0            =  c1 + d1t + c2 + d2t + eta0
      teu1            =  p1 * (c1 - d1t) + p2 * (c2 - d2t) + eta1
      teu2            =  q1 * (c1 + d1t) + q2 * (c2 + d2t) + eta2
      teu3            =  r1 * (c1 - d1t) + r2 * (c2 - d2t) + eta3

      Rdir(k,1)     = (teu0 + 2.0d0 * (teu1 + teu2)) / mu_z
      Rdir(k,2)     =  2.0d0 * (-0.125d0 * teu0 + teu2 + teu3) / mu_z

      ted0            =  c1t + d1 + c2t + d2 + eta0 * dtr(k)
      ted1            =  p1 * (c1t - d1) + p2 * (c2t - d2) + eta1 * dtr(k)
      ted2            =  q1 * (c1t + d1) + q2 * (c2t + d2) + eta2 * dtr(k)
      ted3            =  r1 * (c1t - d1) + r2 * (c2t - d2) + eta3 * dtr(K)
!
      Tdir(k,1)     = (ted0 - 2.0d0 * (ted1 - ted2))  / mu_z
      Tdir(k,2)     =  2.0d0 * (-0.125d0 * ted0 + ted2 - ted3) / mu_z

      c1t             =  ya * e1
      d1t             =  yc * e2
      c2t             =  ye * e1
      d2t             =  yg * e2
!
      teu0            =  ya + d1t + ye + d2t
      teu1            =  p1 * (ya - d1t) + p2 * (ye - d2t)
      teu2            =  q1 * (ya + d1t) + q2 * (ye + d2t)
      teu3            =  r1 * (ya - d1t) + r2 * (ye - d2t)
      Rdiff(k,1,1)   =  0.5d0 * teu0 + teu1 + teu2
      Rdiff(k,2,1)   = -0.125d0 * teu0 + teu2 + teu3
!
      ted0            =  c1t + yc + c2t + yg
      ted1            =  p1 * (c1t - yc) + p2 * (c2t - yg)
      ted2            =  q1 * (c1t + yc) + q2 * (c2t + yg)
      ted3            =  r1 * (c1t - yc) + r2 * (c2t - yg)
      Tdiff(k,1,1)   =  0.5d0 * ted0 - ted1 + ted2
      Tdiff(k,2,1)   = -0.125d0 * ted0 + ted2 - ted3
!
      c1t             =  yb * e1
      d1t             =  yd * e2
      c2t             =  yf * e1
      d2t             =  yh * e2

      teu0            =  yb + d1t + yf + d2t
      teu1            =  p1 * (yb - d1t) + p2 * (yf - d2t)
      teu2            =  q1 * (yb + d1t) + q2 * (yf + d2t)
      teu3            =  r1 * (yb - d1t) + r2 * (yf - d2t)
      Rdiff(k,1,2)   =  0.5d0 * teu0 + teu1 + teu2
      Rdiff(k,2,2)   = -0.125d0 * teu0 + teu2 + teu3
!
      ted0            =  c1t + yd + c2t + yh
      ted1            =  p1 * (c1t - yd) + p2 * (c2t - yh)
      ted2            =  q1 * (c1t + yd) + q2 * (c2t + yh)
      ted3            =  r1 * (c1t - yd) + r2 * (c2t - yh)
      Tdiff(k,1,2)   =  0.5d0 * ted0 - ted1 + ted2
      Tdiff(k,2,2)   = -0.125d0 * ted0 + ted2 - ted3


      !print*, k, Tdir(k,:), Rdir(k,:)
      !print*, k, Tdiff(k,:,:)
      !print*, k, Rdiff(k,:,:)

    end do

    !stop


    !! We now have the transmission and reflection coefficents for both the direct and diffuse components
    !! Now we perform the doubling-adding method accros multiple layers

    !! Do boundary conditons first
    ! Upper
    T1k(1,:) = 0.0_dp
    Rd1k(1,:,:) = 0.0_dp

    ! Lower
    R1k(nlev,1) = w_surf ; R1k(nlev,2) = -w_surf/4.0_dp 
    Rst1k(nlev,1,1) = w_surf ; Rst1k(nlev,1,2) = 0.0_dp
    Rst1k(nlev,2,1) = -w_surf/4.0_dp ; Rst1k(nlev,2,2) = 0.0_dp

    !! Direct transmission to level
    T(:) = exp(-tau(:)/mu_z)

    scumdtr(1) = T(1)

    do k = 2, nlev
      km1 = k - 1        
        c11                =  1.0d0 - Rdiff(km1,1,1) * Rd1k(km1,1,1) - Rdiff(km1,1,2) * Rd1k(km1,2,1)
        c12                =      - Rdiff(km1,1,1) * Rd1k(km1,1,2) - Rdiff(km1,1,2) * Rd1k(km1,2,2)
        c21                =      - Rdiff(km1,2,1) * Rd1k(km1,1,1) - Rdiff(km1,2,2) * Rd1k(km1,2,1)
        c22                =  1.0d0 - Rdiff(km1,2,1) * Rd1k(km1,1,2) - Rdiff(km1,2,2) * Rd1k(km1,2,2)
        pmod             =  c11 * c22 - c12 * c21
        t11              =  c22 / pmod
        t12              = -c12 / pmod
        t21              = -c21 / pmod
        t22              =  c11 / pmod

        b11              =  t11 * Tdiff(km1,1,1) + t12 * Tdiff(km1,2,1)
        b12              =  t11 * Tdiff(km1,1,2) + t12 * Tdiff(km1,2,2)
        b21              =  t21 * Tdiff(km1,1,1) + t22 * Tdiff(km1,2,1)
        b22              =  t21 * Tdiff(km1,1,2) + t22 * Tdiff(km1,2,2)
!
        scumdtr(k)   =  scumdtr(km1)*dtr(km1)
        d1               =  Rdir(km1,1) * scumdtr(km1) + Rdiff(km1,1,1) * T1k(km1,1) + &
                            Rdiff(km1,1,2) * T1k(km1,2)
        d2               =  Rdir(km1,2) * scumdtr(km1) + Rdiff(km1,2,1) * T1k(km1,1) + &
                            Rdiff(km1,2,2) * T1k(km1,2)
        uu1              =  d1 * t11 + d2 * t12
        uu2              =  d1 * t21 + d2 * t22
        du1              =  T1k(km1,1) + uu1 * Rd1k(km1,1,1) + uu2 * Rd1k(km1,1,2)
        du2              =  T1k(km1,2) + uu1 * Rd1k(km1,2,1) + uu2 * Rd1k(km1,2,2)
        T1k(k,1)   =  Tdir(km1,1) * scumdtr(km1) + du1 * Tdiff(km1,1,1) + du2 * Tdiff(km1,1,2)
        T1k(k,2)   =  Tdir(km1,2) * scumdtr(km1) + du1 * Tdiff(km1,2,1) + du2 * Tdiff(km1,2,2)
!
        a11              =  Tdiff(km1,1,1) * Rd1k(km1,1,1) + Tdiff(km1,1,2) * Rd1k(km1,2,1)
        a12              =  Tdiff(km1,1,1) * Rd1k(km1,1,2) + Tdiff(km1,1,2) * Rd1k(km1,2,2)
        a21              =  Tdiff(km1,2,1) * Rd1k(km1,1,1) + Tdiff(km1,2,2) * Rd1k(km1,2,1)
        a22              =  Tdiff(km1,2,1) * Rd1k(km1,1,2) + Tdiff(km1,2,2) * Rd1k(km1,2,2)
        Rd1k(k,1,1) =  Rdiff(km1,1,1) + a11 * b11 + a12 * b21
        Rd1k(k,1,2) =  Rdiff(km1,1,2) + a11 * b12 + a12 * b22
        Rd1k(k,2,1) =  Rdiff(km1,2,1) + a21 * b11 + a22 * b21
        Rd1k(k,2,2) =  Rdiff(km1,2,2) + a21 * b12 + a22 * b22
    end do
  

    do l = nlay, 1, -1
      lp1 = l + 1
        c11              =  1.0d0 - Rst1k(lp1,1,1) * Rdiff(l,1,1) - Rst1k(lp1,1,2) * Rdiff(l,2,1)
        c12              =      - Rst1k(lp1,1,1) * Rdiff(l,1,2) - Rst1k(lp1,1,2) * Rdiff(l,2,2)
        c21              =      - Rst1k(lp1,2,1) * Rdiff(l,1,1) - Rst1k(lp1,2,2) * Rdiff(l,2,1)
        c22              =  1.0d0 - Rst1k(lp1,2,1) * Rdiff(l,1,2) - Rst1k(lp1,2,2) * Rdiff(l,2,2)
        pmod             =  c11 * c22 - c12 * c21
        t11              =  c22 / pmod
        t12              = -c12 / pmod
        t21              = -c21 / pmod
        t22              =  c11 / pmod
        d1               =  R1k(lp1,1) * dtr(l) + Rst1k(lp1,1,1) * Tdir(l,1) + &
                            Rst1k(lp1,1,2) * Tdir(l,2)
        d2               =  R1k(lp1,2) * dtr(l) + Rst1k(lp1,2,1) * Tdir(l,1) + &
                            Rst1k(lp1,2,2) * Tdir(l,2)
        uu1              =  d1 * t11 + d2 * t12
        uu2              =  d1 * t21 + d2 * t22
        R1k(l,1)   =  Rdir(l,1) + uu1 * Tdiff(l,1,1) + uu2 * Tdiff(l,1,2)
        R1k(l,2)   =  Rdir(l,2) + uu1 * Tdiff(l,2,1) + uu2 * Tdiff(l,2,2)
!
        c11              =  1.0d0 - Rdiff(l,1,1) * Rst1k(lp1,1,1) - Rdiff(l,1,2) * Rst1k(lp1,2,1)
        c12              =      - Rdiff(l,1,1) * Rst1k(lp1,1,2) - Rdiff(l,1,2) * Rst1k(lp1,2,2)
        c21              =      - Rdiff(l,2,1) * Rst1k(lp1,1,1) - Rdiff(l,2,2) * Rst1k(lp1,2,1)
        c22              =  1.0d0 - Rdiff(l,2,1) * Rst1k(lp1,1,2) - Rdiff(l,2,2) * Rst1k(lp1,2,2)
        pmod             =  c11 * c22 - c12 * c21
        t11              =  c22 / pmod
        t12              = -c12 / pmod
        t21              = -c21 / pmod
        t22              =  c11 / pmod
!
        r11              =  Tdiff(l,1,1) * (t11 * Rst1k(lp1,1,1) +  t21 * Rst1k(lp1,1,2)) + &
                           & Tdiff(l,1,2) * (t11 * Rst1k(lp1,2,1) +  t21 * Rst1k(lp1,2,2))
        r12              =  Tdiff(l,1,1) * (t12 * Rst1k(lp1,1,1) +  t22 * Rst1k(lp1,1,2)) + &
                          & Tdiff(l,1,2) * (t12 * Rst1k(lp1,2,1) +  t22 * Rst1k(lp1,2,2))
        r21              =  Tdiff(l,2,1) * (t11 * Rst1k(lp1,1,1) +  t21 * Rst1k(lp1,1,2)) + &
                          &  Tdiff(l,2,2) * (t11 * Rst1k(lp1,2,1) +  t21 * Rst1k(lp1,2,2))
        r22              =  Tdiff(l,2,1) * (t12 * Rst1k(lp1,1,1) +  t22 * Rst1k(lp1,1,2)) + &
                          &  Tdiff(l,2,2) * (t12 * Rst1k(lp1,2,1) +  t22 * Rst1k(lp1,2,2))
!
        Rst1k(l,1,1) =  Rdiff(l,1,1) + r11 * Tdiff(l,1,1) + r12 * Tdiff(l,2,1)
        Rst1k(l,1,2) =  Rdiff(l,1,2) + r11 * Tdiff(l,1,2) + r12 * Tdiff(l,2,2)
        Rst1k(l,2,1) =  Rdiff(l,2,1) + r21 * Tdiff(l,1,1) + r22 * Tdiff(l,2,1)
        Rst1k(l,2,2) =  Rdiff(l,2,2) + r21 * Tdiff(l,1,2) + r22 * Tdiff(l,2,2)
    end do

    do k = 1, nlev
        c11              =  1.0d0 - Rst1k(k,1,1) * Rd1k(k,1,1) - Rst1k(k,1,2) * Rd1k(k,2,1)
        c12              =      - Rst1k(k,1,1) * Rd1k(k,1,2) - Rst1k(k,1,2) * Rd1k(k,2,2)
        c21              =      - Rst1k(k,2,1) * Rd1k(k,1,1) - Rst1k(k,2,2) * Rd1k(k,2,1)
        c22              =  1.0d0 - Rst1k(k,2,1) * Rd1k(k,1,2) - Rst1k(k,2,2) * Rd1k(k,2,2)
        pmod             =  c11 * c22 - c12 * c21
        t11              =  c22 / pmod
        t12              = -c12 / pmod
        t21              = -c21 / pmod
        t22              =  c11 / pmod
!
        d1               =  R1k(k,1) * scumdtr(k) + Rst1k(k,1,1) * T1k(k,1) + &
                           & Rst1k(k,1,2) * T1k(k,2)
        d2               =  R1k(k,2) * scumdtr(k) + Rst1k(k,2,1) * T1k(k,1) + &
                           & Rst1k(k,2,2) * T1k(k,2)
        uu1              =  d1 * t11 + d2 * t12
        du1              =  T1k(k,1) + Rd1k(k,1,1) * uu1 + Rd1k(k,1,2) * (d1 * t21 + d2 * t22)
        reflt(k)   =  uu1
        trant(k)   =  du1 + scumdtr(k)

        !print*, k, reflt(k), trant(k), scumdtr(k)
    end do

    sw_down(:) = trant(:)*mu_z*Finc
    sw_up(:) = -reflt(:)*mu_z*Finc

    print*, sw_down(:)

    print*, sw_up(:)

   stop

  end subroutine sw_SDA

  subroutine sw_adding(nlay, nlev, Finc, tau_Ve, mu_z, w_in, g_in, w_surf, sw_down, sw_up)
    implicit none

    !! Input variables
    integer, intent(in) :: nlay, nlev
    real(dp), intent(in) :: Finc, mu_z, w_surf
    real(dp), dimension(nlev), intent(in) :: tau_Ve
    real(dp), dimension(nlay), intent(in) :: w_in, g_in

    !! Output variables
    real(dp), dimension(nlev), intent(out) :: sw_down, sw_up

    !! Work variables
    integer :: k
    real(dp) :: lamtau, e_lamtau, arg, apg, amg
    real(dp), dimension(nlev) ::  om, g, f
    real(dp), dimension(nlev) :: tau_Ve_s
    real(dp), dimension(nlay) :: tau
    real(dp), dimension(nlev) :: tau_s, w_s, g_s
    real(dp), dimension(nlev) :: lam, u, N, gam, alp
    real(dp), dimension(nlev) :: R_b, T_b, R, T
    real(dp), dimension(nlev) :: Tf

    ! Design w and g to include surface property level
    om(1:nlay) = w_in(:)
    g(1:nlay) = g_in(:)

    om(nlev) = 0.0_dp
    g(nlev) = 0.0_dp

    ! If zero albedo across all atmospheric layers then return direct beam only
    if (all(om(:) <= 1.0e-12_dp)) then
      sw_down(:) = Finc * mu_z * exp(-tau_Ve(:)/mu_z)
      sw_down(nlev) = sw_down(nlev) * (1.0_dp - w_surf) ! The surface flux for surface heating is the amount of flux absorbed by surface
      sw_up(:) = 0.0_dp ! We assume no upward flux here even if surface albedo
      return
    end if

    om(nlev) = w_surf
    g(nlev) = 0.0_dp

    ! Backscattering approximation
    f(:) = g(:)**2

    !! Do optical depth rescaling
    tau_Ve_s(1) = tau_Ve(1)
    do k = 1, nlay
      tau(k) = tau_Ve(k+1) - tau_Ve(k)
      tau_s(k) = tau(k) * (1.0_dp - om(k)*f(k))
      tau_Ve_s(k+1) = tau_Ve_s(k) + tau_s(k)
    end do

    do k = 1, nlev

      w_s(k) = om(k) * ((1.0_dp - f(k))/(1.0_dp - om(k)*f(k)))
      g_s(k) = (g(k) - f(k))/(1.0_dp - f(k))
      lam(k) = sqrt(3.0_dp*(1.0_dp - w_s(k))*(1.0_dp - w_s(k)*g_s(k)))
      gam(k) = 0.5_dp * w_s(k) * (1.0_dp + 3.0_dp*g_s(k)*(1.0_dp - w_s(k))*mu_z**2)/(1.0_dp - lam(k)**2*mu_z**2)
      alp(k) = 0.75_dp * w_s(k) * mu_z * (1.0_dp + g_s(k)*(1.0_dp - w_s(k)))/(1.0_dp - lam(k)**2*mu_z**2)
      u(k) = (3.0_dp/2.0_dp) * ((1.0_dp - w_s(k)*g_s(k))/lam(k))

      lamtau = min(lam(k)*tau_Ve_s(k),99.0_dp)
      e_lamtau = exp(-lamtau)

      N(k) = (u(k) + 1.0_dp)**2 * 1.0_dp/e_lamtau - (u(k) - 1.0_dp)**2  * e_lamtau

      R_b(k) = (u(k) + 1.0_dp)*(u(k) - 1.0_dp)*(1.0_dp/e_lamtau - e_lamtau)/N(k)
      T_b(k) = 4.0_dp * u(k)/N(k)

      arg = min(tau_Ve_s(k)/mu_z,99.0_dp)
      Tf(k) = exp(-arg)

      apg = alp(k) + gam(k)
      amg = alp(k) - gam(k)

      R(k) = amg*(T_b(k)*Tf(k) - 1.0_dp) + apg*R_b(k)

      T(k) = apg*T_b(k) + (amg*R_b(k) - (apg - 1.0_dp))*Tf(k)

      R(k) = max(R(k), 0.0_dp)
      T(k) = max(T(k), 0.0_dp)
      R_b(k) = max(R_b(k), 0.0_dp)
      T_b(k) = max(T_b(k), 0.0_dp)

    end do

    !! Calculate downward flux
    do k = 1, nlay
      sw_down(k) = Tf(k) + ((T(k) - Tf(k)) +  &
      & Tf(k)*R(k+1)*R_b(k))/(1.0_dp - R_b(k)*R_b(k+1))
    end do
    sw_down(nlev) = Tf(nlev)

    !! Calculate upward flux
    do k = 1, nlay
      sw_up(k) = (Tf(k)*R(k+1) + (T(k) - Tf(k))*R_b(k+1))/(1.0_dp - R_b(k)*R_b(k+1))
    end do
    sw_up(nlev) = sw_down(nlev) * w_surf

    !! Scale with the incident flux
    sw_down(:) = sw_down(:) * mu_z * Finc
    sw_up(:) = sw_up(:) * mu_z * Finc

    ! print*, sw_down(:)
    ! print*, sw_up(:)

    ! stop

  end subroutine sw_adding

  pure function matinv4(A) result(B)
    !! Performs a direct calculation of the inverse of a 4Ã—4 matrix.
    real(dp), intent(in) :: A(4,4)   !! Matrix
    real(dp)             :: B(4,4)   !! Inverse matrix
    real(dp)             :: detinv

    ! Calculate the inverse determinant of the matrix
    detinv = &
      1.0_dp/&
      & (A(1,1)*(A(2,2)*(A(3,3)*A(4,4)-A(3,4)*A(4,3))+A(2,3)*(A(3,4)*A(4,2)-A(3,2)*A(4,4))+A(2,4)*(A(3,2)*A(4,3)-A(3,3)*A(4,2)))&
      & - A(1,2)*(A(2,1)*(A(3,3)*A(4,4)-A(3,4)*A(4,3))+A(2,3)*(A(3,4)*A(4,1)-A(3,1)*A(4,4))+A(2,4)*(A(3,1)*A(4,3)-A(3,3)*A(4,1)))&
      & + A(1,3)*(A(2,1)*(A(3,2)*A(4,4)-A(3,4)*A(4,2))+A(2,2)*(A(3,4)*A(4,1)-A(3,1)*A(4,4))+A(2,4)*(A(3,1)*A(4,2)-A(3,2)*A(4,1)))&
      & - A(1,4)*(A(2,1)*(A(3,2)*A(4,3)-A(3,3)*A(4,2))+A(2,2)*(A(3,3)*A(4,1)-A(3,1)*A(4,3))+A(2,3)*(A(3,1)*A(4,2)-A(3,2)*A(4,1))))

    ! Calculate the inverse of the matrix
    B(1,1) = detinv*(A(2,2)*(A(3,3)*A(4,4)-A(3,4)*A(4,3))+A(2,3)*(A(3,4)*A(4,2)-A(3,2)*A(4,4))+A(2,4)*(A(3,2)*A(4,3)-A(3,3)*A(4,2)))
    B(2,1) = detinv*(A(2,1)*(A(3,4)*A(4,3)-A(3,3)*A(4,4))+A(2,3)*(A(3,1)*A(4,4)-A(3,4)*A(4,1))+A(2,4)*(A(3,3)*A(4,1)-A(3,1)*A(4,3)))
    B(3,1) = detinv*(A(2,1)*(A(3,2)*A(4,4)-A(3,4)*A(4,2))+A(2,2)*(A(3,4)*A(4,1)-A(3,1)*A(4,4))+A(2,4)*(A(3,1)*A(4,2)-A(3,2)*A(4,1)))
    B(4,1) = detinv*(A(2,1)*(A(3,3)*A(4,2)-A(3,2)*A(4,3))+A(2,2)*(A(3,1)*A(4,3)-A(3,3)*A(4,1))+A(2,3)*(A(3,2)*A(4,1)-A(3,1)*A(4,2)))
    B(1,2) = detinv*(A(1,2)*(A(3,4)*A(4,3)-A(3,3)*A(4,4))+A(1,3)*(A(3,2)*A(4,4)-A(3,4)*A(4,2))+A(1,4)*(A(3,3)*A(4,2)-A(3,2)*A(4,3)))
    B(2,2) = detinv*(A(1,1)*(A(3,3)*A(4,4)-A(3,4)*A(4,3))+A(1,3)*(A(3,4)*A(4,1)-A(3,1)*A(4,4))+A(1,4)*(A(3,1)*A(4,3)-A(3,3)*A(4,1)))
    B(3,2) = detinv*(A(1,1)*(A(3,4)*A(4,2)-A(3,2)*A(4,4))+A(1,2)*(A(3,1)*A(4,4)-A(3,4)*A(4,1))+A(1,4)*(A(3,2)*A(4,1)-A(3,1)*A(4,2)))
    B(4,2) = detinv*(A(1,1)*(A(3,2)*A(4,3)-A(3,3)*A(4,2))+A(1,2)*(A(3,3)*A(4,1)-A(3,1)*A(4,3))+A(1,3)*(A(3,1)*A(4,2)-A(3,2)*A(4,1)))
    B(1,3) = detinv*(A(1,2)*(A(2,3)*A(4,4)-A(2,4)*A(4,3))+A(1,3)*(A(2,4)*A(4,2)-A(2,2)*A(4,4))+A(1,4)*(A(2,2)*A(4,3)-A(2,3)*A(4,2)))
    B(2,3) = detinv*(A(1,1)*(A(2,4)*A(4,3)-A(2,3)*A(4,4))+A(1,3)*(A(2,1)*A(4,4)-A(2,4)*A(4,1))+A(1,4)*(A(2,3)*A(4,1)-A(2,1)*A(4,3)))
    B(3,3) = detinv*(A(1,1)*(A(2,2)*A(4,4)-A(2,4)*A(4,2))+A(1,2)*(A(2,4)*A(4,1)-A(2,1)*A(4,4))+A(1,4)*(A(2,1)*A(4,2)-A(2,2)*A(4,1)))
    B(4,3) = detinv*(A(1,1)*(A(2,3)*A(4,2)-A(2,2)*A(4,3))+A(1,2)*(A(2,1)*A(4,3)-A(2,3)*A(4,1))+A(1,3)*(A(2,2)*A(4,1)-A(2,1)*A(4,2)))
    B(1,4) = detinv*(A(1,2)*(A(2,4)*A(3,3)-A(2,3)*A(3,4))+A(1,3)*(A(2,2)*A(3,4)-A(2,4)*A(3,2))+A(1,4)*(A(2,3)*A(3,2)-A(2,2)*A(3,3)))
    B(2,4) = detinv*(A(1,1)*(A(2,3)*A(3,4)-A(2,4)*A(3,3))+A(1,3)*(A(2,4)*A(3,1)-A(2,1)*A(3,4))+A(1,4)*(A(2,1)*A(3,3)-A(2,3)*A(3,1)))
    B(3,4) = detinv*(A(1,1)*(A(2,4)*A(3,2)-A(2,2)*A(3,4))+A(1,2)*(A(2,1)*A(3,4)-A(2,4)*A(3,1))+A(1,4)*(A(2,2)*A(3,1)-A(2,1)*A(3,2)))
    B(4,4) = detinv*(A(1,1)*(A(2,2)*A(3,3)-A(2,3)*A(3,2))+A(1,2)*(A(2,3)*A(3,1)-A(2,1)*A(3,3))+A(1,3)*(A(2,1)*A(3,2)-A(2,2)*A(3,1)))
  end function

  ! Perform linear interpolation in log10 space
  subroutine linear_log_interp(xval, x1, x2, y1, y2, yval)
    implicit none

    real(dp), intent(in) :: xval, y1, y2, x1, x2
    real(dp) :: ly1, ly2
    real(dp), intent(out) :: yval
    real(dp) :: norm

    ly1 = log10(y1); ly2 = log10(y2)

    norm = 1.0_dp / log10(x2/x1)

    yval = 10.0_dp**((ly1 * log10(x2/xval) + ly2 * log10(xval/x1)) * norm)

  end subroutine linear_log_interp

  subroutine bezier_interp(xi, yi, ni, x, y)
    implicit none

    integer, intent(in) :: ni
    real(dp), dimension(ni), intent(in) :: xi, yi
    real(dp), intent(in) :: x
    real(dp), intent(out) :: y

    real(dp) :: dx, dx1, dy, dy1, wh, yc, t, wlim, wlim1

    !xc = (xi(1) + xi(2))/2.0_dp ! Control point (no needed here, implicitly included)
    dx = xi(2) - xi(1)
    dx1 = xi(3) - xi(2)
    dy = yi(2) - yi(1)
    dy1 = yi(3) - yi(2)

    if (x > xi(1) .and. x < xi(2)) then
      ! left hand side interpolation
      !print*,'left'
      wh = dx1/(dx + dx1)
      wlim = 1.0_dp + 1.0_dp/(1.0_dp - (dy1/dy) * (dx/dx1))
      wlim1 = 1.0_dp/(1.0_dp - (dy/dy1) * (dx1/dx))
      if (wh <= min(wlim,wlim1) .or. wh >= max(wlim,wlim1)) then
        wh = 1.0_dp
      end if
      yc = yi(2) - dx/2.0_dp * (wh*dy/dx + (1.0_dp - wh)*dy1/dx1)
      t = (x - xi(1))/dx
      y = (1.0_dp - t)**2 * yi(1) + 2.0_dp*t*(1.0_dp - t)*yc + t**2*yi(2)
    else ! (x > xi(2) and x < xi(3)) then
      ! right hand side interpolation
      !print*,'right'
      wh = dx/(dx + dx1)
      wlim = 1.0_dp/(1.0_dp - (dy1/dy) * (dx/dx1))
      wlim1 = 1.0_dp + 1.0_dp/(1.0_dp - (dy/dy1) * (dx1/dx))
      if (wh <= min(wlim,wlim1) .or. wh >= max(wlim,wlim1)) then
        wh = 1.0_dp
      end if
      yc = yi(2) + dx1/2.0_dp * (wh*dy1/dx1 + (1.0_dp - wh)*dy/dx)
      t = (x - xi(2))/(dx1)
      y = (1.0_dp - t)**2 * yi(2) + 2.0_dp*t*(1.0_dp - t)*yc + t**2*yi(3)
    end if

  end subroutine bezier_interp

end module ts_AA_E_mod